#include "stdafx.h"
#include "AVIList.h"

				/////////////////////////
				//  AVILIST - Methoden //
				/////////////////////////

AVILIST::AVILIST(void) 
{
	iFiles=0;
	dwMaxNbrOfFiles=0;
	lplpOpenFiles=NULL;
	siPartialStreams=NULL;
	bAllowCrapAC3=false;
};

AVILIST::~AVILIST(void) {};

int AVILIST::Open(DWORD _dwMaxNbrOfFiles)
{
	dwMaxNbrOfFiles=_dwMaxNbrOfFiles;
	lplpOpenFiles=(AVIFILEEX**)malloc(4*dwMaxNbrOfFiles+4);
	ZeroMemory(lplpOpenFiles,4*dwMaxNbrOfFiles+4);
	return AFE_OK;
}

bool AVILIST::Close(bool bCloseFiles)
{
	if (iFiles==0) return true;
	FreePartialStreams();

	if (bCloseFiles)
	{
		for (int i=0;i<iFiles;lplpOpenFiles[i++]->Close());
	}

	delete lplpOpenFiles;
	iFiles=0;
	return true;
}

bool AVILIST::AllowCrapAC3(bool bAllow)
{
	bool bOld=bAllow;
	bAllowCrapAC3=bAllow;
	return bAllow;
}

bool AVILIST::CanAppend(AVIFILEEX* NextFile)
{
	DWORD				dwX1,dwX2,dwY1,dwY2,i;
	AVIStreamHeader*	strh1,*strh2;
	BITMAPINFOHEADER*	lpbmi1,*lpbmi2;
	WAVEFORMATEX*		lpwfe1,*lpwfe2;

	if (iFiles==0) return true;

	AVIFILEEX*	FirstFile=lplpOpenFiles[0];

// Auflösung muß gleich sein
	NextFile->GetVideoResolution(&dwX1,&dwY1);
	FirstFile->GetVideoResolution(&dwX2,&dwY2);
	if ((dwX1!=dwX2)||(dwY1!=dwY2)) return false;

	strh1=FirstFile->GetStreamHeader(0);
	strh2=NextFile->GetStreamHeader(0);
// Video-Codec muß gleich sein
	if (strh1->fccHandler!=strh2->fccHandler) return false;
	lpbmi1=(BITMAPINFOHEADER*)FirstFile->GetStreamFormat(0);
	lpbmi2=(BITMAPINFOHEADER*)NextFile->GetStreamFormat(0);
// Bitdepth muß gleich sein
	if (lpbmi1->biBitCount!=lpbmi2->biBitCount) return false;

// Framerate muß gleich sein   NICHT MEHR
//	if (FirstFile->GetMicroSecPerFrame()!=NextFile->GetMicroSecPerFrame()) return false;
// Anzahl Streams muß gleich sein
	if (FirstFile->GetNbrOfStreams()!=NextFile->GetNbrOfStreams()) return false;
// Audiostreams überprüfen:
	for (i=0;i<FirstFile->GetNbrOfStreams();i++)
	{
		if (FirstFile->GetKindOfStream(i)!=NextFile->GetKindOfStream(i))
		{
			return false;
		}

		if (FirstFile->IsAudioStream(i))
		{
			lpwfe1=(WAVEFORMATEX*)FirstFile->GetStreamFormat(i);
			lpwfe2=(WAVEFORMATEX*)NextFile->GetStreamFormat(i);
		// gleiches FormatTag:
			if (lpwfe1->wFormatTag!=lpwfe2->wFormatTag) return false;
		// für nicht-MP3:
			if ((lpwfe1->wFormatTag!=0x55)&&((lpwfe1->wFormatTag!=0x2000)||(!bAllowCrapAC3)))
			{
			// gleiche Datenrate:
//				if (lpwfe1->nAvgBytesPerSec!=lpwfe2->nAvgBytesPerSec) return false;
			// gleiche Kanäle:
				if (lpwfe1->nChannels!=lpwfe2->nChannels) return false;
			// gleiche Frequenz
				if (lpwfe1->nSamplesPerSec!=lpwfe2->nSamplesPerSec) return false;
			// gleiche Granularität
				if (FirstFile->GetStreamGranularity(i)!=NextFile->GetStreamGranularity(i)) return false;
			}
		}
	}
	return true;
}

__int64 AVILIST::GetByteStreamPos(DWORD dwStreamNbr)
{
	DWORD dwFileNbr=siStreams[dwStreamNbr].dwPos;
	AVIFILEEX*	avifile;

	avifile=lplpOpenFiles[dwFileNbr];
	if (!dwFileNbr)
	{
		return avifile->GetByteStreamPos(dwStreamNbr);
	}
	else
	{
		if (avifile)
		{
			return avifile->GetByteStreamPos(dwStreamNbr)+siPartialStreams[dwFileNbr-1][dwStreamNbr].qwStreamLength;
		}
		else
		{
			return siPartialStreams[dwFileNbr-1][dwStreamNbr].qwStreamLength;
		}
	}
}

void AVILIST::FreePartialStreams()
{
    int		j;

	if (siPartialStreams) 
	{
		for (j=0;j<iFiles;j++)
		{
			if (siPartialStreams[j])
			{
				free(siPartialStreams[j]);
				siPartialStreams[j]=NULL;
			}
		}
	}
	free(siPartialStreams);
	siPartialStreams=NULL;
}

bool AVILIST::Append(AVIFILEEX* AVIFile)
{
	int		i,j;

	if (iFiles==(int)dwMaxNbrOfFiles) return false;
	if (!CanAppend(AVIFile)) return false;
	FreePartialStreams();
	lplpOpenFiles[iFiles++]=AVIFile;

	siPartialStreams=(STREAMINFO**)malloc(iFiles*4);
	ZeroMemory(siPartialStreams,4*iFiles);
	for (j=0;j<iFiles;j++)
	{
		siPartialStreams[j]=(STREAMINFO*)malloc(GetNbrOfStreams()*sizeof(STREAMINFO));
		ZeroMemory(siPartialStreams[j],sizeof(STREAMINFO)*GetNbrOfStreams());
		for (i=0;i<(int)GetNbrOfStreams();i++)
		{
			siPartialStreams[j][i].qwStreamLength=((j)?siPartialStreams[j-1][i].qwStreamLength:0)+lplpOpenFiles[j]->GetStreamSize(i);
			siPartialStreams[j][i].dwChunkCount=((j)?siPartialStreams[j-1][i].dwChunkCount:0)+lplpOpenFiles[j]->GetNbrOfChunks(i);
		}
	}
	siStreams=siPartialStreams[iFiles-1];
	return true;
}

void AVILIST::SetProcessMode(DWORD dwNbr,DWORD dwProcessMode)
{
	int	i;

	if (iFiles==0) return;
	for (i=0;i<iFiles;lplpOpenFiles[i++]->SetProcessMode(dwNbr,dwProcessMode));
}

DWORD AVILIST::GetProcessMode(DWORD dwNbr)
{
	if (iFiles==0) return 0;

	return lplpOpenFiles[0]->GetProcessMode(dwNbr);
}

DWORD AVILIST::GetNbrOfStreams(void)
{
	if (!iFiles) return false;
	return lplpOpenFiles[0]->GetNbrOfStreams();
}

__int64 AVILIST::GetFileSize(void)
{
	int			i;
	__int64	qwRes=0;

	if (!iFiles) return AFE_INVALIDCALL;

	for (i=0;i<iFiles;qwRes+=lplpOpenFiles[i++]->GetFileSize());
	return qwRes;
}

DWORD AVILIST::GetFormatTag(DWORD dwStreamNbr)
{
	if (!iFiles) return AFE_INVALIDCALL;

	return (lplpOpenFiles[0]->GetFormatTag(dwStreamNbr));
}

int AVILIST::GetVideoResolution(DWORD *lpWidth,DWORD *lpHeight)
{
	if (!iFiles) return AFE_INVALIDCALL;
	return lplpOpenFiles[0]->GetVideoResolution(lpWidth,lpHeight);
}

DWORD AVILIST::GetNbrOfChunks(DWORD dwStreamNbr)
{
	if (!iFiles) return AFE_INVALIDCALL;
	return (siStreams[dwStreamNbr].dwChunkCount);
}

bool AVILIST::IsCBR(DWORD dwStreamNbr)
{
	bool	bCBR=true;
	
	if (!iFiles) return false;
	for (int i=0;i<iFiles;i++)
	{
		bCBR=bCBR&&(lplpOpenFiles[i]->IsCBR(dwStreamNbr))&&(lplpOpenFiles[0]->GetAvgBytesPerSec(dwStreamNbr)==lplpOpenFiles[i]->GetAvgBytesPerSec(dwStreamNbr));
	}
	return bCBR;
}

__int64 AVILIST::GetStreamSize(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return (siStreams[dwStreamNbr].qwStreamLength);
}

bool AVILIST::IsAudioStream(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->IsAudioStream(dwStreamNbr);
}

bool AVILIST::IsVideoStream(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->IsVideoStream(dwStreamNbr);
}

bool AVILIST::IsTextStream(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->IsTextStream(dwStreamNbr);
}

DWORD AVILIST::GetKindOfStream(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetKindOfStream(dwStreamNbr);
}


DWORD AVILIST::GetNbrOfFile(DWORD dwStreamNbr,__int64 qwPos)
{
	int		i;

	if (IsAudioStream(dwStreamNbr))
	{
		i=0;
		while ((siPartialStreams[i][dwStreamNbr].qwStreamLength<=qwPos)&&(i<(int)iFiles-1))
		{
			i++;
		}
	}
	if (IsVideoStream(dwStreamNbr))
	{
		i=0;
		while ((siPartialStreams[i][0].dwChunkCount<qwPos)&&(i<(int)iFiles-1))
		{
			i++;
		}
	}

	return i;
}

int AVILIST::SeekByteStream(DWORD dwStreamNbr,__int64 qwPos)
{
	__int64	qwOffset;
	DWORD		dwNbrOfFile;

	if (!iFiles) return AFE_INVALIDCALL;
	if (qwPos>GetStreamSize(dwStreamNbr)) return AFE_INVALIDPARAM;
	if (qwPos==GetStreamSize(dwStreamNbr))
	{
		dwNbrOfFile=iFiles-1;
	}
	else
	{
		dwNbrOfFile=GetNbrOfFile(dwStreamNbr,qwPos);
	}

	siStreams[dwStreamNbr].dwPos=dwNbrOfFile;
	qwOffset=qwPos-((dwNbrOfFile)?siPartialStreams[dwNbrOfFile-1][dwStreamNbr].qwStreamLength:0);
	lplpOpenFiles[dwNbrOfFile]->SeekByteStream(dwStreamNbr,qwOffset);

	return AFE_OK;
}

int AVILIST::GetStreamGranularity(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetStreamGranularity(dwStreamNbr);
}

int AVILIST::GetStreamFrequency(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetStreamFrequency(dwStreamNbr);
}

int AVILIST::SeekVideoStream(DWORD dwPos)
{
	DWORD		dwOffset;
	DWORD		dwNbrOfFile;

	if (!iFiles) return AFE_INVALIDCALL;
	if (dwPos>GetNbrOfChunks(0)) return AFE_INVALIDPARAM;

	dwNbrOfFile=GetNbrOfFile(0,dwPos);
	siStreams[0].dwPos=dwNbrOfFile;
	dwOffset=dwPos-((dwNbrOfFile)?siPartialStreams[dwNbrOfFile-1][0].dwChunkCount:0);

	lplpOpenFiles[dwNbrOfFile]->SeekVideoStream(dwOffset);

	return AFE_OK;
}

DWORD AVILIST::LoadAudioData(DWORD dwStreamNbr,DWORD dwBytes,void* lpDest)
{
	DWORD		dwRead,dwTotal;
	BYTE*		lpbDest=(BYTE*)lpDest;

	dwRead=1;
	dwTotal=0;

	if (!IsEndOfStream(dwStreamNbr))
	{
		while ((dwRead)&&(dwTotal<dwBytes))
		{
			AVIFILEEX*	AVIFile=lplpOpenFiles[siStreams[dwStreamNbr].dwPos];
			if (AVIFile)
			{
				dwTotal+=(dwRead=AVIFile->LoadAudioData(dwStreamNbr,dwBytes-dwTotal,&(lpbDest[dwTotal])));
				if (AVIFile->IsEndOfStream(dwStreamNbr)&&((int)siStreams[dwStreamNbr].dwPos<iFiles-1))
				{
					siStreams[dwStreamNbr].dwPos++;
					AVIFILEEX*	AVIFile=lplpOpenFiles[siStreams[dwStreamNbr].dwPos];
					AVIFile->SeekByteStream(dwStreamNbr,0);
				}
			}
			else
				dwRead=0;
		}
	}
	else
	{
		*((DWORD*)(lpDest))=0;
		dwRead=0;
		dwTotal=0;
	}
	return dwTotal;
}

bool AVILIST::IsKeyFrame(DWORD dwChunkNbr)
{
	DWORD		dwOffset;
	DWORD		dwNbrOfFile;
	AVIFILEEX*	AVIFile;

	if (dwChunkNbr==CN_CURRENT_CHUNK)
	{
		AVIFile=lplpOpenFiles[siStreams[0].dwPos];
				
		return AVIFile->IsKeyFrame(CN_CURRENT_CHUNK);
	}
	if (dwChunkNbr==CN_PREV_CHUNK)
	{
		AVIFile=lplpOpenFiles[siStreams[0].dwPos];
		if (AVIFile)
		{
			if (AVIFile->GetCurrChunk(0)==0) AVIFile=lplpOpenFiles[siStreams[0].dwPos-1];
		}
		else
		{
			AVIFile=lplpOpenFiles[siStreams[0].dwPos-1];
		}

		return AVIFile->IsKeyFrame(CN_PREV_CHUNK);
	}

	dwNbrOfFile=GetNbrOfFile(0,dwChunkNbr);
	if (dwNbrOfFile)
	{
		dwOffset=dwChunkNbr-siPartialStreams[dwNbrOfFile-1][0].dwChunkCount;
	}
	else
	{
		dwOffset=dwChunkNbr;
	}
	return lplpOpenFiles[dwNbrOfFile]->IsKeyFrame(dwOffset);
}

AVIStreamHeader* AVILIST::GetStreamHeader(DWORD dwStreamNbr)
{
	if (!iFiles) return NULL;
	return lplpOpenFiles[0]->GetStreamHeader(dwStreamNbr);
}

void* AVILIST::GetStreamFormat(DWORD dwStreamNbr)
{
	if (!iFiles) return NULL;
	return lplpOpenFiles[0]->GetStreamFormat(dwStreamNbr);
}

DWORD AVILIST::GetMicroSecPerFrame(void)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetMicroSecPerFrame();
}

__int64 AVILIST::GetNanoSecPerFrame(void)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetNanoSecPerFrame();
}

int AVILIST::GetVideoChunk(DWORD dwChunkNbr,void* lpDest,DWORD* lpdwSize)
{
	if (dwChunkNbr==CN_NEXT_CHUNK)
	{
		if (!IsEndOfStream(0))
		{
			DWORD	dwNbrOfFile=siStreams[0].dwPos;
			AVIFILEEX* AVIFile=lplpOpenFiles[dwNbrOfFile];
			AVIFile->GetVideoChunk(dwChunkNbr,lpDest,lpdwSize);
			if (AVIFile->IsEndOfStream(0))
			{
				if ((int)siStreams[0].dwPos<iFiles-1)
				{
					siStreams[0].dwPos++;
					DWORD	dwNbrOfFile=siStreams[0].dwPos;
					AVIFile=lplpOpenFiles[dwNbrOfFile];
					AVIFile->SeekVideoStream(0);			
				}
			}
		}
		else
		{
			if (lpdwSize) *lpdwSize=NULL;
		}
	}
	
	return AFE_OK;
}

bool AVILIST::IsEndOfStream(DWORD dwStreamNbr)
{
	return 
		(
		  ((int)siStreams[dwStreamNbr].dwPos>=iFiles)||
		  (((int)siStreams[dwStreamNbr].dwPos==iFiles-1)&&(lplpOpenFiles[iFiles-1]->IsEndOfStream(dwStreamNbr)))
		);
}

DWORD AVILIST::GetAvgBytesPerSec(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetAvgBytesPerSec(dwStreamNbr);
}

int AVILIST::GetChannels(DWORD dwStreamNbr)
{
	if (!iFiles) return 0;
	return lplpOpenFiles[0]->GetChannels(dwStreamNbr);
}

DWORD AVILIST::GetCurrChunk(DWORD dwStreamNbr)
{
	if (!siStreams[dwStreamNbr].dwPos)
	{
		return lplpOpenFiles[0]->GetCurrChunk(dwStreamNbr);
	}
	else
	{
		return siPartialStreams[siStreams[dwStreamNbr].dwPos-1][dwStreamNbr].dwChunkCount+
			lplpOpenFiles[siStreams[dwStreamNbr].dwPos]->GetCurrChunk(dwStreamNbr);

	}
	return 0;
}

int AVILIST::InvalidateCache()
{
	for (int i=0;i<iFiles;lplpOpenFiles[i++]->InvalidateCache());
	return AFE_OK;
}

int AVILIST::GetNbrOfFrames(DWORD dwKind)
{
	int		i;
	int		iRes;

	iRes=0;
	for (i=0;i<iFiles;iRes+=lplpOpenFiles[i++]->GetNbrOfFrames(dwKind));

	return iRes;
}

int AVILIST::GetStreamName(DWORD dwStream,char* lpcName)
{
	lplpOpenFiles[0]->GetStreamName(dwStream,lpcName);
	return 1;
}

int AVILIST::SetStreamName(DWORD dwStream,char* lpcName)
{
	return 0;
}